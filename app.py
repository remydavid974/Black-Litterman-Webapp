import pandas as pd
import streamlit as st
import numpy as np
import altair as alt
import plotly.graph_objects as go

st.set_page_config(page_title="Black-Litterman Strategy", layout="wide")

@st.cache_data
def load_data(file):
    return pd.read_csv(file, index_col=0, parse_dates=True)
def format_metric(index, values):
    formatted = []
    for metric_name, val in zip(index, values.squeeze()):
        if metric_name == "Annualized Sharpe Ratio":
            formatted.append(f"{val:.2f}")
        else:
            formatted.append(f"{val * 100:.2f}%")
    return formatted

def get_key_from_value(d, value):
    return next(k for k, v in d.items() if v == value)


# --- Load data ---
cum_ret_BL = load_data("cum_ret_df_BL.csv")
cum_ret_NV = load_data("cum_ret_df_NV.csv")
cum_ret_VW = load_data("cum_ret_df_VW.csv")
dd_BL = load_data("drawdown_df_BL.csv")
dd_NV = load_data("drawdown_df_NV.csv")
dd_VW = load_data("drawdown_df_VW.csv")
metric_BL = load_data("metric_df_BL.csv")
metric_NV = load_data("metric_df_NV.csv")
metric_VW = load_data("metric_df_VW.csv")

# --- Extract parameter BL ---
params_BL = cum_ret_BL.columns.str.extract(r'win=(\d+)_risk=(\d+)_tc=([\d.]+)_tv=([\d.]+|inf)_tp=([\d.]+)')
params_BL.columns = ['win', 'risk', 'tc', 'tv', 'tp']
params_BL = params_BL.astype({'win': int, 'risk': int, 'tc': float, 'tv': float, 'tp': float})
params_BL['col_name'] = cum_ret_BL.columns

# --- Extract parameter VW ---
params_VW= cum_ret_VW.columns.str.extract(r'tc=([\d.]+)_tv=([\d.]+|inf)')
params_VW.columns = ['tc', 'tv']
params_VW = params_VW.astype({'tc': float, 'tv': float})
params_VW['col_name'] = cum_ret_VW.columns

# --- Define all dictionaries (before using them) ---

win_options = {
    "60 days": 60,
    "90 days": 90,
    "120 days": 120,
}

vol_options = {
    "None": np.inf,
    "10%": 0.10,
    "15%": 0.15,
    "20%": 0.20,
    "25%": 0.25
}

tc_options = {
    "None": 0.0000,
    "0,1%": 0.0010,
    "0,25%": 0.0025,
    "0,5%": 0.0050,
}


if "full_param_toggle" not in st.session_state:
    st.session_state["full_param_toggle"] = True  # or False depending on your desired default


# Tabs
tab1, tab2 = st.tabs(["👋 Welcome & Strategy Overview", "📊 Strategy Performance"])

# --- Tab 1: Strategy Overview ---
with tab1:
    st.header("👋 Welcome to My Black-Litterman Portfolio Strategy App")

    st.markdown("""
    This interactive app presents a data-driven investment strategy built using the **Black-Litterman model**, enhanced with **sentiment signals**.

    - 📈 The goal: build a realistic multi-asset portfolio that adapts to market sentiment **each day**.
    - 🧠 Sentiment signals are extracted from **Stocktwits**, a social media platform where retail investors share ideas, opinions, and sentiment on individual stocks.
    - 📊 Views are generated by analyzing changes in investor sentiment and mapped into the Black-Litterman framework.
    - 🧪 The final portfolio includes **realistic features**: transaction costs, volatility controls, turnover penalties and out-of-sample testing.
    """)

    with st.expander("🔬 More Details: How the Strategy is Built"):
        # --- Tickers Universe ---
        tickers_by_type = {
        "Tech & Growth": ['AAPL', 'AMD', 'AMZN', 'FB', 'NFLX', 'TSLA'],
        "Biotech & Pharma": ['AMRN', 'MNKD'],
        "Banks & Finance": ['BAC', 'BB'],
        "ETFs & Indexes": ['QQQ', 'SPY', 'IWM', 'GLD', 'JNUG', 'UVXY'],
        "Green Energy": ['PLUG'],
        "China Stocks": ['BABA']
        }

        st.markdown("### 🧾 Ticker Universe")
        st.markdown(
        "The portfolio includes a mix of individual stocks and ETFs, grouped by theme.  \n"
        "_Tickers were selected based on their popularity and message volume on Stocktwits — "
        "i.e., the most discussed assets to ensure robust sentiment signals._"
)


        col1, col2, col3 = st.columns([1,1,1])

        groups = list(tickers_by_type.items())
        half = len(groups) // 2

        for col, subset in zip([col1, col2], [groups[:half], groups[half:]]):
            with col:
                for group, names in subset:
                    st.markdown(f"**{group}:**")
                    st.markdown(", ".join(f"`{ticker}`" for ticker in names) + "\n")
        with col3:
            st.empty()
        # --- Polarity Computation ---
        st.markdown("### 🧮 **Polarity Computation**")
        st.markdown("   - Each day, Stocktwits messages are classified as bullish, bearish or neutral using an NLP model.")
        st.markdown("   - The **polarity score** is defined as:")

        col1, col2, col3 = st.columns([1,1,1])
        with col1:
            st.latex(r"P_{i,t} = \frac{\# \text{Bullish} - \# \text{Bearish}}{\# \text{Bullish} + \# \text{Bearish}}")
        with col2:
            st.latex(r"""
            \begin{array}{rl}
            \scriptstyle \# & \scriptstyle \text{ number of messages} \\
            \scriptstyle i & \scriptstyle \text{ firm} \\
            \scriptstyle t & \scriptstyle \text{ day}
            \end{array}
            """)
        with col3:
            st.empty()
        
        # --- Implied Return Construction ---
        st.markdown("### 📐 Implied Return Construction")
        st.markdown(
        "In the Black-Litterman framework, views are anchored to a prior: the **implied returns**, "
        "which are reverse-engineered from an initial portfolio.  \n"
        "In this strategy, the prior portfolio is chosen to be the **value-weighted portfolio** (based on market caps), "
        "which reflects a passive market allocation.  \n"
        "This ensures the implied returns are grounded in a realistic benchmark and allows sentiment-based views to adjust them meaningfully."
        )
        st.markdown("The implied return is calculated using:")
        col1, col2, col3 = st.columns([1,1,1])
        with col1:
            st.latex(r"\mu_{\text{implied}} = \lambda \cdot \Sigma \cdot w_{\text{mkt}}")

        with col2:
            st.latex(r"""
            \begin{array}{rl}
            \scriptstyle \mu_{\text{implied}} & \scriptstyle \text{ implied expected return} \\
            \scriptstyle \lambda & \scriptstyle \text{ risk aversion} \\
            \scriptstyle \Sigma & \scriptstyle \text{ covariance matrix} \\
            \scriptstyle w_{\text{mkt}} & \scriptstyle \text{ value-weighted market portfolio}
            \end{array}
            """)
        with col3:
            st.empty() 
        # --- Signal Estimation ---
        st.markdown("### 🧪 **Signal Estimation**")
        st.markdown("- A **rolling regression** is performed to estimate the relationship between returns and polarity changes:")

        col1, col2, col3 = st.columns([1, 1, 1])
        with col1:
            st.latex(r"\Delta r_{i,t+1} = \beta_i \cdot \Delta \text{Polarity}_{i,t} + \epsilon_{i,t+1}")
        with col2:
            st.latex(r"""
            \begin{array}{rl}
            \scriptstyle \Delta r_{i,t+1} & \scriptstyle \text{change in return of stock } i \text{ from } t \text{ to } t{+}1 \\
            \scriptstyle \beta_i & \scriptstyle \text{sensitivity to polarity} \\
            \scriptstyle \Delta \text{Polarity}_{i,t} & \scriptstyle \text{change in polarity from } t{-}1 \text{ to } t \\
            \scriptstyle \epsilon_{i,t+1} & \scriptstyle \text{regression residual}
            \end{array}
            """)
        with col3:
            st.empty()

        st.markdown("""
                    - From each regression, we extract the **t-statistic** (used to assess signal strength) and the **residual variance** (used later in the Omega matrix).
                    - The **t-statistic** serves as a direct measure of confidence in the polarity signal.
                    - A **gamma factor** is applied later to scale the polarity signal based on this strength (see *View Construction*).""")

        # --- View Construction ---
        st.markdown("### 🧠 **View Construction (Q Matrix)**")
        st.markdown("""
                    - In the Black-Litterman framework, a **view** represents the investor's own estimate of future returns for the assets, based on additional information or insights.
                    - In theory, since the regression links changes in polarity to next-day returns variation, one could directly estimate the expected return as:""")
        
        col1, col2 = st.columns([1,2])
        with col1:
            st.latex(r"\mathbb{E}[r_t] = r_{t-1} + \Delta \text{Polarity} \times \beta")
        with col2:
            st.empty()
                   
        st.markdown(r"""
                    But in practice, this approach is **very sensitive to noise** and highly volatile.
                    - Instead, the strategy anchors the forecast on the **Black-Litterman implied return** ($\mu_{implied}$), and then applies a **signal-based adjustment**:""",
                    unsafe_allow_html=True)
        col1, col2 = st.columns([1,2])
        with col1:
            st.latex(r"Q = \mu_{\text{implied}} + \gamma \cdot \Delta \text{ Polarity} \times \beta")
        with col2:
            st.empty()  
        st.markdown(r"""
                    This makes the views more robust, stable over time, and consistent with the Black-Litterman philosophy, where investor views are treated as corrections to the market equilibrium.
                   - **We only retain statistically significant signals**:  
                    A view is included only if the _absolute t-statistic_ exceeds 2 (i.e., $|t_i| > 2$); in that case, a **sigmoid function** is applied to scale $\gamma$ based on the t-statistic.  
                    Otherwise, the signal is ignored by setting $\gamma = 0$.


                    - **Views are conditionally activated based on recent price movement**:  
                    If the _absolute return_ on the previous day is below a quantile threshold, we also set $\gamma = 0$.

                    - **The quantile threshold is adaptive and based on market volatility**:  
                    - In _high volatility_, weak returns may still be informative, so we use a **low quantile threshold** to _include more views_.  
                    - In _low volatility_, only strong signals are trusted, so we use a **high quantile threshold** to _filter out weak moves_.
                    
                    <p style="font-size: 0.85em; font-style: italic; margin-top: 0.75em;">
                    These design choices were informed by empirical analysis of the model's performance:
                    I observed that the signal filter and adaptive quantile improve
                    <strong>robustness</strong> and <strong>responsiveness</strong> across different
                    <em>volatility regimes</em>.
                    </p>
                    """,unsafe_allow_html=True)

        # --- Omega matrix ---
        st.markdown("### 📏 **Omega Matrix Construction**")
        st.markdown("""
                    In the Black-Litterman framework, the Omega matrix encodes the **uncertainty** of the investor’s views. Lower values indicate **greater confidence**, while higher values reflect **greater uncertainty**.\n
                    I use the following confidence-scaling formula:""")
        col1,col2,col3 = st.columns(3)
        with col1:
            st.latex(r"\Omega_{ii} = \frac{\sigma^2_{\varepsilon,i}}{\left(\frac{t_i}{\gamma}\right)^2 + \varepsilon}")
        with col2:
                st.latex(r"""
                \begin{array}{rl}
                \scriptstyle \sigma^2_{\varepsilon,i} & \scriptstyle \text{residual variance of the regression for asset } i \\
                \scriptstyle t_i & \scriptstyle \text{t-statistic of the polarity-return relationship for asset } i \\
                \scriptstyle \gamma & \scriptstyle \text{confidence scaling parameter (set to 1)} \\
                \scriptstyle \varepsilon & \scriptstyle \text{small constant to avoid division by zero}
                \end{array}
                """)
        with col3:
            st.empty()   
        st.markdown(r"""
                    - $t$ measures the strength of the signal from the polarity-return regression. A higher $t$-statistic increases confidence in the view (lower $\Omega_{ii}$).
                    - $\sigma^2_{\varepsilon,i}$ captures the noise or uncertainty in the regression. A higher residual variance means the signal is less reliable, so it increases $\Omega_{ii}$ and reduces the impact of the view.
                    - For signals with weak statistical strength (already filtered with $|t| < 2$), we assign $\Omega_{ii} = \infty$, effectively ignoring those views in the optimization.""")
    
        # --- Black-Litterman Inputs ---
        st.markdown("### 🧩 **Portfolio Optimization Inputs & Constraints**")
        st.markdown(r"""
        - The optimization aims to find portfolio weights that maximize expected return while accounting for risk and turnover costs. The objective function incorporates:
            - **Expected return** ($w^\top \mu$)
            - **Risk penalty** ($\frac{1}{2} \lambda w^\top \Sigma w$)
            - **Turnover penalty** ($\tau \cdot \|w - w_{\text{prev}}\|_1$), which discourages excessive rebalancing.
        - The optimization includes constraints:
            - ✅ **Fully invested** (weights sum to 1)
            - ❌ **No short-selling** (weights ≥ 0)
            - ❌ **No leverage** (weights ≤ 1)
        - **Volatility targeting** is applied after optimization to maintain a stable portfolio risk level over time (e.g., targeting 10% annualized volatility).
         Any residual weight not allocated to risky assets is automatically invested in a **risk-free asset** to satisfy the full investment constraint.
        """)



# --- Tab 2: Strategy Performance ---
with tab2:
    # Title and subtitle
    st.markdown("## 📊 Strategy Results")

    
    column1,column2 = st.columns(2)
    with column1:
        col10,col11= st.columns(2)
        with col10: 
            st.markdown("#### 🎯 Pre-selected Parameters")
        with col11:
            st.toggle("**Allow full parameter optimization**", key="full_param_toggle", help="Optimizer adjusts all parameters. If off, only risk aversion and turnover penalty change. Transaction costs are fixed.")
          
    with column2:
        st.markdown("#### 🎚️ Manual Parameters")
    col1,col2,col3,col4,col5,col6,col7,col8,col9 = st.columns([1.2,1.2,1.2,1.2,0.94,0.94,0.94,0.94,0.94])
    with col1:
        st.markdown("<div style='padding-top: 28px;'>", unsafe_allow_html=True)
        if st.session_state["full_param_toggle"] == True:
            if st.button("📈 Max Sharpe", use_container_width=True,help="Finds the configuration that maximizes the annualized Sharpe ratio."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_tc_val = tc_options[selected_tc]
                # Filter columns that contain the correct tc
                matching_cols = [col for col in metric_BL.columns if f"tc={selected_tc_val}" in col]
                # Now find best among the filtered
                best_col = metric_BL[matching_cols].loc["Annualized Sharpe Ratio"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                # --- Update session state to reflect new parameters ---
                st.session_state["rolling_window_label"] = get_key_from_value(win_options,best_params["win"])
                st.session_state["target_vol_label"] = get_key_from_value(vol_options, best_params["tv"])
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["turnover_penalty"] = best_params["tp"]   
            
        else:
            if st.button("📈 Max Sharpe", use_container_width=True,help="Finds the configuration that maximizes the annualized Sharpe ratio."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_win = st.session_state["rolling_window_label"]
                selected_vol = st.session_state["target_vol_label"]
                selected_tc_val = tc_options[selected_tc]
                selected_win_val = win_options[selected_win]
                selected_vol_val = vol_options[selected_vol]
                # Filter columns that contain value not changed
                matching_cols = [col for col in metric_BL.columns 
                                    if f'win={selected_win_val}'in col and 
                                    f'tc={selected_tc_val}_tv={selected_vol_val}' in col]
                best_col = metric_BL[matching_cols].loc["Annualized Sharpe Ratio"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["turnover_penalty"] = best_params["tp"]
            
            
                
        st.markdown("</div>", unsafe_allow_html=True)

    with col2:
        st.markdown("<div style='padding-top: 28px;'>", unsafe_allow_html=True)
        if st.session_state["full_param_toggle"] == True:
            if st.button("🔉 Min Volatility", use_container_width=True, help="Finds the configuration with the lowest annualized volatility."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_tc_val = tc_options[selected_tc]
                # Filter columns that contain the correct tc
                matching_cols = [col for col in metric_BL.columns if f"tc={selected_tc_val}" in col]
                # Now find best among the filtered
                best_col = metric_BL[matching_cols].loc["Annualized Volatility"].idxmin()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                # --- Update session state to reflect new parameters ---
                st.session_state["rolling_window_label"] = get_key_from_value(win_options,best_params["win"])
                st.session_state["target_vol_label"] = get_key_from_value(vol_options, best_params["tv"])
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["turnover_penalty"] = best_params["tp"] 
        else:
            if st.button("🔉 Min Volatility", use_container_width=True, help="Finds the configuration with the lowest annualized volatility."): 
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_win = st.session_state["rolling_window_label"]
                selected_vol = st.session_state["target_vol_label"]
                selected_tc_val = tc_options[selected_tc]
                selected_win_val = win_options[selected_win]
                selected_vol_val = vol_options[selected_vol]
                # Filter columns that contain value not changed
                matching_cols = [col for col in metric_BL.columns 
                                    if f'win={selected_win_val}'in col and 
                                    f'tc={selected_tc_val}_tv={selected_vol_val}' in col]
                best_col = metric_BL[matching_cols].loc["Annualized Volatility"].idxmin()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["turnover_penalty"] = best_params["tp"]
                               
        st.markdown("</div>", unsafe_allow_html=True)

    with col3:
        st.markdown("<div style='padding-top: 28px;'>", unsafe_allow_html=True)
        if st.session_state["full_param_toggle"] == True:
            if st.button("📉 Max Drawdown", use_container_width=True, help="Minimizes the maximum historical drawdown."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_tc_val = tc_options[selected_tc]
                # Filter columns that contain the correct tc
                matching_cols = [col for col in metric_BL.columns if f"tc={selected_tc_val}" in col]
                # Now find best among the filtered
                best_col = metric_BL[matching_cols].loc["Max Drawdown"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                # --- Update session state to reflect new parameters ---
                st.session_state["rolling_window_label"] = get_key_from_value(win_options,best_params["win"])
                st.session_state["target_vol_label"] = get_key_from_value(vol_options, best_params["tv"])
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["turnover_penalty"] = best_params["tp"]     
                
        else:
            if st.button("📉 Max Drawdown", use_container_width=True, help="Minimizes the maximum historical drawdown."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_win = st.session_state["rolling_window_label"]
                selected_vol = st.session_state["target_vol_label"]
                selected_tc_val = tc_options[selected_tc]
                selected_win_val = win_options[selected_win]
                selected_vol_val = vol_options[selected_vol]
                # Filter columns that contain value not changed
                matching_cols = [col for col in metric_BL.columns 
                                    if f'win={selected_win_val}'in col and 
                                    f'tc={selected_tc_val}_tv={selected_vol_val}' in col]
                best_col = metric_BL[matching_cols].loc["Max Drawdown"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["turnover_penalty"] = best_params["tp"]
                       
        st.markdown("</div>", unsafe_allow_html=True)
    with col4:
        st.markdown("<div style='padding-top: 28px;'>", unsafe_allow_html=True)
        if st.session_state["full_param_toggle"] == True:
            if st.button("🚀 Max Return", use_container_width=True, help="Finds the configuration with the highest total return."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_tc_val = tc_options[selected_tc]
                # Filter columns that contain the correct tc
                matching_cols = [col for col in metric_BL.columns if f"tc={selected_tc_val}" in col]
                # Now find best among the filtered
                best_col = metric_BL[matching_cols].loc["Annualized Return"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                # --- Update session state to reflect new parameters ---
                st.session_state["rolling_window_label"] = get_key_from_value(win_options,best_params["win"])
                st.session_state["target_vol_label"] = get_key_from_value(vol_options, best_params["tv"])
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["turnover_penalty"] = best_params["tp"]  
                    
        else:
            if st.button("🚀 Max Return", use_container_width=True, help="Finds the configuration with the highest total return."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_win = st.session_state["rolling_window_label"]
                selected_vol = st.session_state["target_vol_label"]
                selected_tc_val = tc_options[selected_tc]
                selected_win_val = win_options[selected_win]
                selected_vol_val = vol_options[selected_vol]
                # Filter columns that contain value not changed
                matching_cols = [col for col in metric_BL.columns 
                                    if f'win={selected_win_val}'in col and 
                                    f'tc={selected_tc_val}_tv={selected_vol_val}' in col]
                best_col = metric_BL[matching_cols].loc["Annualized Return"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["turnover_penalty"] = best_params["tp"]
                    
        st.markdown("</div>", unsafe_allow_html=True)
            

    with col5: 
        win_label_select = st.selectbox(
            "Rolling window", options=list(win_options.keys()),
            key="rolling_window_label",help="Sets the lookback period for signal calculation.")
        window = win_options[st.session_state["rolling_window_label"]]
        
        
    with col6:  
        vt_label_select = st.selectbox(
            "Target volatility", options=list(vol_options.keys()),
            key="target_vol_label",
            help="Adjusts portfolio weights to maintain a target annualized volatility level.")
        target_vol = vol_options[st.session_state["target_vol_label"]]

    
    with col7:
        tc_label_select = st.selectbox(
            "Transaction costs", options=list(tc_options.keys()),
            key="trans_cost_label",
            help="Specifies the transaction cost applied at each rebalancing step.")
        trans_cost = tc_options[st.session_state["trans_cost_label"]]
            

    with col8:
        risk_aversion = st.select_slider("Risk aversion",options=[1,2,3,4,5],key="risk_aversion_value",
                                         help="Controls how conservative the optimizer is. Higher values mean lower risk-taking.(Not in this strategy, need further diagnosys)")
        
        
    with col9:
        
        turn_pen = st.select_slider(
            "Turnover penalty",
            options=np.arange(0.0010, 0.0026, 0.0001),
            format_func=lambda x: f"{x:.4f}",
            key="turnover_penalty",
            help="Penalize the turnover. Higher value means higher penalization."
        )
                     

        
    st.markdown("#### 📈 Portfolios Performance")
    col1,col2 = st.columns([1,3])
    with col1:
        
            # --- Select the correct column based on slider inputs ---
        selected_col_BL = params_BL[
            (params_BL['win'] == window) &
            (params_BL['risk'] == risk_aversion) &
            (params_BL['tc'] == trans_cost) &
            (params_BL['tv'] == target_vol) &
            (params_BL['tp'] == turn_pen) 
        ]['col_name'].values


        selected_col_VW = params_VW[
            (params_VW['tc'] == trans_cost) &
            (params_VW['tv'] == target_vol) 
        ]['col_name'].values


        data = {
            "Metric": metric_BL.index,
            "Portfolio with Views": format_metric(metric_BL.index, metric_BL[selected_col_BL]),
            "Portfolio without Views": format_metric(metric_NV.index, metric_NV[selected_col_BL]),
            "Market Portfolio": format_metric(metric_VW.index, metric_VW[selected_col_VW]),
        }
        
        df = pd.DataFrame(data)


        def render_plotly_table(df):
            fig = go.Figure(data=[go.Table(
                header=dict(
                    values=list(df.columns),
                    fill_color='#f0f2f6',
                    align='center',
                    font=dict(color='black', size=13)
                ),
                cells=dict(
                    values=[df[col] for col in df.columns],
                    fill_color='white',
                    align='center',
                    font=dict(color='black', size=12),
                    height=28
                )
            )])
            fig.update_layout(margin=dict(l=0, r=0, t=0, b=0))
            st.plotly_chart(fig, use_container_width=True)
            
        st.markdown("##  \n")  # 1 empty line
        render_plotly_table(df)

        
        
        
    with col2:
        
        
        
        # --- Prepare data for ploting ---
        # BL
        plot_cr_BL = cum_ret_BL[selected_col_BL].reset_index()
        plot_cr_BL.columns = ['Date', 'Cumulative Return'] 
        plot_cr_BL['Cumulative Return'] = plot_cr_BL['Cumulative Return'].astype(float)
        
        plot_dd_BL = dd_BL[selected_col_BL].reset_index()
        plot_dd_BL.columns = ['Date', 'Drawdown'] 
        plot_dd_BL['Drawdown'] = plot_dd_BL['Drawdown'].astype(float)
        
        # NV
        plot_cr_NV = cum_ret_NV[selected_col_BL].reset_index()
        plot_cr_NV.columns = ['Date', 'Cumulative Return'] 
        plot_cr_NV['Cumulative Return'] = plot_cr_NV['Cumulative Return'].astype(float)
        
        plot_dd_NV = dd_NV[selected_col_BL].reset_index()
        plot_dd_NV.columns = ['Date', 'Drawdown'] 
        plot_dd_NV['Drawdown'] = plot_dd_NV['Drawdown'].astype(float)
        # VW
        plot_cr_VW = cum_ret_VW[selected_col_VW].reset_index()
        plot_cr_VW.columns = ['Date', 'Cumulative Return'] 
        plot_cr_VW['Cumulative Return'] = plot_cr_VW['Cumulative Return'].astype(float)
        
        plot_dd_VW = dd_VW[selected_col_VW].reset_index()
        plot_dd_VW.columns = ['Date', 'Drawdown'] 
        plot_dd_VW['Drawdown'] = plot_dd_VW['Drawdown'].astype(float)
        
        latest_BL = plot_cr_BL.sort_values("Date").iloc[-1] 
        latest_NV = plot_cr_NV.sort_values("Date").iloc[-1] 
        latest_VW = plot_cr_VW.sort_values("Date").iloc[-1]
        
        latest_returns = pd.DataFrame({
        "Date": [latest_BL["Date"], latest_NV["Date"], latest_VW["Date"]],
        "Total Return": [latest_BL["Cumulative Return"] -1 , latest_NV["Cumulative Return"] -1, latest_VW["Cumulative Return"]-1],
        "Portfolio": ["Portfolio with Views", "Portfolio without Views", "Market Portfolio"]
        })
        

        # --- Name portfolios ---
        plot_cr_BL['Strategy'] = 'Portfolio with Views'
        plot_cr_NV['Strategy'] = 'Portfolio without Views'
        plot_cr_VW['Strategy'] = 'Market Portfolio'
        
        plot_dd_BL['Strategy'] = 'Portfolio with Views'
        plot_dd_NV['Strategy'] = 'Portfolio without Views'
        plot_dd_VW['Strategy'] = 'Market Portfolio'

        # Combine into one long-format DataFrame
        combined_data_cr = pd.concat([plot_cr_BL, plot_cr_NV,plot_cr_VW], ignore_index=True)
        combined_data_cr["Cumulative Return"] = combined_data_cr["Cumulative Return"] - 1
        combined_data_dd = pd.concat([plot_dd_BL, plot_dd_NV,plot_dd_VW], ignore_index=True)
        
        combined_data = pd.merge(
        combined_data_cr,
        combined_data_dd,
        on=["Date", "Strategy"],
        how="inner"
        )

            # Pivot data to wide format
        pivoted = combined_data.pivot(index="Date", columns="Strategy", values=["Cumulative Return", "Drawdown"]).reset_index()
        # Flatten MultiIndex columns
        pivoted.columns = ['Date'] + [f"{metric} {strategy}" for metric, strategy in pivoted.columns[1:]]
        pivoted["Tooltip VW"] = pivoted.apply(
            lambda row: f"Views \u2003\u2009\u2009\u2009\u200A\u200A\u200A| R: {row['Cumulative Return Portfolio with Views']:.1%} | DD: {row['Drawdown Portfolio with Views']:.1%}",
            axis=1
        )
        pivoted["Tooltip NV"] = pivoted.apply(
            lambda row: f"No Views | R: {row['Cumulative Return Portfolio without Views']:.1%} | DD: {row['Drawdown Portfolio without Views']:.1%}",
            axis=1
        )
        pivoted["Tooltip MP"] = pivoted.apply(
            lambda row: f"Market \u00A0\u00A0\u00A0\u2009 | R: {row['Cumulative Return Market Portfolio']:.1%} | DD: {row['Drawdown Market Portfolio']:.1%}",
            axis=1
        )

        # --- Create the nearest-point selection ---
        nearest = alt.selection_point(
            nearest=True,
            on="pointerover",
            fields=["Date"],
            empty=False
        )

        # --- Line chart for Cumulative Return ---
        line_cr = alt.Chart(combined_data).mark_line(strokeWidth=1.5).encode(
            x=alt.X("Date:T", axis=None),
            y=alt.Y("Cumulative Return:Q", title="Total Return", axis=alt.Axis(format=".0%")),
            color=alt.Color(
                "Strategy:N",
                title="",
                scale=alt.Scale(
                    domain=["Portfolio with Views", "Portfolio without Views", "Market Portfolio"],
                    range=['#2ca02c', '#d62728', '#1f77b4']
                )
            )
        )
        min_dd = combined_data_dd["Drawdown"].min()

        # --- Line chart for Drawdown ---
        line_dd = alt.Chart(combined_data).mark_line(strokeWidth=1.5).encode(
            x=alt.X("Date:T", title="Date"),
            y=alt.Y("Drawdown:Q", title="Drawdown", axis=alt.Axis(format=".0%"),
                    scale=alt.Scale(domain=[min_dd, 0.01],nice=False)),
            color=alt.Color(
                "Strategy:N", legend=alt.Legend(orient='top-left'),
                title="",
                scale=alt.Scale(
                    domain=["Portfolio with Views", "Portfolio without Views", "Market Portfolio"],
                    range=['#2ca02c', '#d62728', '#1f77b4']
                )
            )
        )

        # --- Points for Return chart ---
        points_cr = alt.Chart(combined_data).mark_point().encode(
            x="Date:T",
            y="Cumulative Return:Q",
            color=alt.Color("Strategy:N", scale=alt.Scale(
                domain=["Portfolio with Views", "Portfolio without Views", "Market Portfolio"],
                range=["#2ca02c", "#d62728", "#1f77b4"]
            )),
            opacity=alt.condition(nearest, alt.value(1), alt.value(0))
        )

        # --- Points for Drawdown chart ---
        points_dd = alt.Chart(combined_data).mark_point().encode(
            x="Date:T",
            y="Drawdown:Q",
            color=alt.Color("Strategy:N", scale=alt.Scale(
                domain=["Portfolio with Views", "Portfolio without Views", "Market Portfolio"],
                range=["#2ca02c", "#d62728", "#1f77b4"]
            )),
            opacity=alt.condition(nearest, alt.value(1), alt.value(0))
        )

        
        tooltip=[
            alt.Tooltip("Date:T", title="    "),
            alt.Tooltip("Tooltip VW:N", title=" "),
            alt.Tooltip("Tooltip NV:N", title="  "),
            alt.Tooltip("Tooltip MP:N", title="   "),
        ]
        
        zero_line = alt.Chart(pivoted).mark_rule(color='black', strokeWidth=1).encode(
            y=alt.datum(0))
        text_labels = alt.Chart(latest_returns).mark_text(
            align='left',
            dx=5,
            dy=0,
            fontSize=12,
            fontWeight='bold'
        ).encode(
            x="Date:T",
            y=alt.Y("Total Return:Q"),
            text=alt.Text("Total Return:Q", format=".1%"),
            color="Portfolio:N"
        )


        rules = alt.Chart(pivoted).mark_rule(color="gray").encode(
            x="Date:T",
            opacity=alt.condition(nearest, alt.value(0.3), alt.value(0)),
            tooltip=tooltip
        ).add_params(nearest)





        chart_cr = alt.layer(line_cr, points_cr, rules,text_labels).properties(
            width=800,
            height=250,
        )


            
        chart_dd = alt.layer(line_dd, points_dd, rules,zero_line).properties(
            width=800,
            height=180,
        )

        # --- Final synchronized display ---
        full_chart = alt.vconcat(chart_cr, chart_dd,spacing=0).resolve_scale(x='shared').configure_title(
        anchor='middle'  # Use 'start', 'middle', or 'end'
        )
        

        st.altair_chart(full_chart, use_container_width=True)
