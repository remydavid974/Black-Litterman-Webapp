import pandas as pd
import streamlit as st
import numpy as np
import altair as alt
st.set_page_config(page_title="Black-Litterman Strategy", layout="wide")

@st.cache_data
def load_data(file):
    return pd.read_csv(file, index_col=0, parse_dates=True)
def format_metric(index, values):
    formatted = []
    for metric_name, val in zip(index, values.squeeze()):
        if metric_name == "Annualized Sharpe Ratio":
            formatted.append(f"{val:.2f}")
        else:
            formatted.append(f"{val * 100:.2f}%")
    return formatted

def get_key_from_value(d, value):
    return next(k for k, v in d.items() if v == value)


# --- Load data ---
cum_ret_BL = load_data("cum_ret_df_BL.csv")
cum_ret_NV = load_data("cum_ret_df_NV.csv")
cum_ret_VW = load_data("cum_ret_df_VW.csv")
dd_BL = load_data("drawdown_df_BL.csv")
dd_NV = load_data("drawdown_df_NV.csv")
dd_VW = load_data("drawdown_df_VW.csv")
metric_BL = load_data("metric_df_BL.csv")
metric_NV = load_data("metric_df_NV.csv")
metric_VW = load_data("metric_df_VW.csv")

# --- Extract parameter BL ---
params_BL = cum_ret_BL.columns.str.extract(r'win=(\d+)_risk=([\d.]+)_omega=([\d.]+)_tc=([\d.]+)_tv=([\d.]+|inf)')
params_BL.columns = ['win', 'risk', 'omega', 'tc', 'tv']
params_BL = params_BL.astype({'win': int, 'risk': float, 'omega': float, 'tc': float, 'tv': float})
params_BL['col_name'] = cum_ret_BL.columns
# --- Extract parameter NV ---
params_NV = cum_ret_NV.columns.str.extract(r'win=(\d+)_risk=([\d.]+)_tc=([\d.]+)_tv=([\d.]+|inf)')
params_NV.columns = ['win', 'risk', 'tc', 'tv']
params_NV = params_NV.astype({'win': int, 'risk': float, 'tc': float, 'tv': float})
params_NV['col_name'] = cum_ret_NV.columns
# --- Extract parameter VW ---
params_VW= cum_ret_VW.columns.str.extract(r'tc=([\d.]+)_tv=([\d.]+|inf)')
params_VW.columns = ['tc', 'tv']
params_VW = params_VW.astype({'tc': float, 'tv': float})
params_VW['col_name'] = cum_ret_VW.columns

# --- Define all dictionaries (before using them) ---

win_options = {
    "60 days": 60,
    "90 days": 90,
    "120 days": 120,
}

vol_options = {
    "None": np.inf,
    "10%": 0.10,
    "15%": 0.15,
}

tc_options = {
    "0,1%": 0.0010,
    "0,25%": 0.0025,
    "0,5%": 0.0050,
}
if "full_param_toggle" not in st.session_state:
    st.session_state["full_param_toggle"] = True  # or False depending on your desired default


# Tabs
tab1, tab2 = st.tabs(["üëã Welcome & Strategy Overview", "üìä Strategy Performance"])

# --- Tab 1: Strategy Overview ---
with tab1:
    st.header("üëã Welcome to My Black-Litterman Portfolio Strategy App")

    st.markdown("""
    This interactive app presents a data-driven investment strategy built using the **Black-Litterman model**, enhanced with **sentiment signals**.

    - üìà The goal: build a realistic multi-asset portfolio that adapts to market sentiment **each day**.
    - üß† Sentiment signals are extracted from **Stocktwits**, a social media platform where retail investors share ideas, opinions, and sentiment on individual stocks.
    - üìä Views are generated by analyzing changes in investor sentiment and mapped into the Black-Litterman framework.
    - üß™ The final portfolio includes **realistic features**: transaction costs, volatility controls, and out-of-sample testing.

    This strategy originally started as a group project, but I later **rebuilt it independently** to improve its structure, add deeper modeling, and make it suitable for real-world use.
    """)

    with st.expander("üî¨ More Details: How the Strategy is Built"):
        # --- Tickers Universe ---
        tickers_by_type = {
        "Tech & Growth": ['AAPL', 'AMD', 'AMZN', 'FB', 'NFLX', 'TSLA'],
        "Biotech & Pharma": ['AMRN', 'MNKD'],
        "Banks & Finance": ['BAC', 'BB'],
        "ETFs & Indexes": ['QQQ', 'SPY', 'IWM', 'GLD', 'JNUG', 'UVXY'],
        "Green Energy": ['PLUG'],
        "China Stocks": ['BABA']
        }

        st.markdown("### üßæ Ticker Universe")
        st.markdown(
        "The portfolio includes a mix of individual stocks and ETFs, grouped by theme.  \n"
        "_Tickers were selected based on their popularity and message volume on Stocktwits ‚Äî "
        "i.e., the most discussed assets to ensure robust sentiment signals._"
)


        col1, col2, col3 = st.columns([1,1,1])

        groups = list(tickers_by_type.items())
        half = len(groups) // 2

        for col, subset in zip([col1, col2], [groups[:half], groups[half:]]):
            with col:
                for group, names in subset:
                    st.markdown(f"**{group}:**")
                    st.markdown(", ".join(f"`{ticker}`" for ticker in names) + "\n")
        with col3:
            st.empty()
        # --- Polarity Computation ---
        st.markdown("### üßÆ **Polarity Computation**")
        st.markdown("   - Each day, Stocktwits messages are classified as bullish, bearish or neutral using an NLP model.")
        st.markdown("   - The **polarity score** is defined as:")

        col1, col2, col3 = st.columns([1,1,1])
        with col1:
            st.latex(r"P_{i,t} = \frac{\# \text{Bullish} - \# \text{Bearish}}{\# \text{Bullish} + \# \text{Bearish}}")
        with col2:
            st.latex(r"""
            \begin{array}{rl}
            \scriptstyle \# & \scriptstyle \text{ number of messages} \\
            \scriptstyle i & \scriptstyle \text{ firm} \\
            \scriptstyle t & \scriptstyle \text{ day}
            \end{array}
            """)
        with col3:
            st.empty()
        # --- Signal Estimation ---
        st.markdown("### üî¨ **Signal Estimation**")
        st.markdown("- A **rolling regression** is performed to estimate the relationship between returns and polarity changes:")

        col1, col2, col3 = st.columns([1, 1,1])
        with col1:
            st.latex(r"\Delta r_{i,t+1} = \beta_i \cdot \Delta \text{Polarity}_{i,t} + \epsilon_{i,t+1}")
        with col2:
            st.latex(r"""
            \begin{array}{rl}
            \scriptstyle \Delta r_{i,t+1} & \scriptstyle \text{ change in return of stock } i \text{ from } t \text{ to } t+1 \\
            \scriptstyle \beta_i & \scriptstyle \text{ sensitivity to polarity} \\
            \scriptstyle \Delta \text{Polarity}_{i,t} & \scriptstyle \text{ change in polarity from } t{-}1 \text{ to } t \\
            \scriptstyle \epsilon_{i,t+1} & \scriptstyle \text{ regression residual}
            \end{array}
            """)
        with col3:
            st.empty()
        st.markdown("- The **t-statistic** is used to filter out weak signals (views with |t| < 1.5 are discarded).")
        st.markdown("- A **gamma factor** is applied to scale the polarity signal based on t-stat strength.")
        
        # --- Implied Return Construction ---
        st.markdown("### üìê Implied Return Construction")
        st.markdown(
        "In the Black-Litterman framework, views are anchored to a prior: the **implied returns**, "
        "which are reverse-engineered from an initial portfolio.  \n"
        "In this strategy, the prior portfolio is chosen to be the **value-weighted portfolio** (based on market caps), "
        "which reflects a passive market allocation.  \n"
        "This ensures the implied returns are grounded in a realistic benchmark and allows sentiment-based views to adjust them meaningfully."
        )
        st.markdown("The implied return is calculated using:")
        col1, col2, col3 = st.columns([1,1,1])
        with col1:
            st.latex(r"\mu_{\text{implied}} = \lambda \cdot \Sigma \cdot w_{\text{mkt}}")

        with col2:
            st.latex(r"""
            \begin{array}{rl}
            \scriptstyle \mu_{\text{implied}} & \scriptstyle \text{ implied expected return} \\
            \scriptstyle \lambda & \scriptstyle \text{ risk aversion} \\
            \scriptstyle \Sigma & \scriptstyle \text{ covariance matrix} \\
            \scriptstyle w_{\text{mkt}} & \scriptstyle \text{ value-weighted market portfolio}
            \end{array}
            """)
        with col3:
            st.empty() 

        # --- View Construction ---
        st.markdown("### üß† **View Construction (Q Matrix)**")
        st.markdown("""
                    - In the Black-Litterman framework, a **view** represents the investor's own estimate of future returns for the assets, based on additional information or insights.
                    - In theory, since the regression links changes in polarity to next-day returns variation, one could directly estimate the expected return as:""")
        
        col1, col2 = st.columns([1,2])
        with col1:
            st.latex(r"\mathbb{E}[r_t] = r_{t-1} + \Delta \text{Polarity} \times \beta")
        with col2:
            st.empty()
                   
        st.markdown("""
                    But in practice, this approach is **very sensitive to noise** and highly volatile.
                    - Instead, the strategy anchors the forecast on the **Black-Litterman implied return** \\(Œº<sub>implied</sub>), and then applies a **signal-based adjustment**:""",
                    unsafe_allow_html=True)
        col1, col2 = st.columns([1,2])
        with col1:
            st.latex(r"Q = \mu_{\text{implied}} + \gamma \cdot \Delta \text{ Polarity} \times \beta")
        with col2:
            st.empty()  
        st.markdown("""
                    This makes the views more robust, stable over time, and consistent with the Black-Litterman philosophy, where investor views are treated as corrections to the market equilibrium.
                    """)

        # --- Black-Litterman Inputs ---
        st.markdown("### üß© **Black-Litterman Inputs**")
        st.markdown("""
        - The model uses **absolute views** (not relative), meaning each view reflects an expected return rather than a ranking.  
        - The **Omega matrix** captures uncertainty in the views and is scaled based on signal strength (e.g., t-stats).  
        - The final **posterior returns** are derived from the model and used to compute **optimized portfolio weights** under constraints.
        - The optimization includes constraints:
            - ‚úÖ Fully invested (weights sum to 1)
            - ‚ùå No short-selling (weights ‚â• 0)
            - ‚ùå No leverage (weights ‚â§ 1)
        - **Volatility targeting** is applied after optimization to maintain a stable portfolio risk level over time (e.g., targeting 10% annualized volatility).
         Any residual weight not allocated to risky assets is automatically invested in a **risk-free asset** to satisfy the full investment constraint.
        """)



# --- Tab 2: Strategy Performance ---
with tab2:
    # Title and subtitle
    st.markdown("## üìä Strategy Results")
    
    # # Add vertical space before title
    #st.markdown("##  \n")  # 1 empty line
    
    
    column1,column2 = st.columns(2)
    with column1:
        col10,col11= st.columns(2)
        with col10: 
            st.markdown("#### üéØ Pre-selected Parameters")
        with col11:
            st.toggle("**Allow full parameter optimization**", key="full_param_toggle", help="Optimizer adjusts all parameters. If off, only risk aversion and omega change. Transaction costs are fixed.")
          
    with column2:
        st.markdown("#### üéöÔ∏è Manual Parameters")
    col1,col2,col3,col4,col5,col6,col7,col8,col9 = st.columns([1.2,1.2,1.2,1.2,0.94,0.94,0.94,0.95,0.94])
    with col1:
        st.markdown("<div style='padding-top: 28px;'>", unsafe_allow_html=True)
        if st.session_state["full_param_toggle"] == True:
            if st.button("üìà Max Sharpe", use_container_width=True,help="Finds the configuration that maximizes the annualized Sharpe ratio."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_tc_val = tc_options[selected_tc]
                # Filter columns that contain the correct tc
                matching_cols = [col for col in metric_BL.columns if f"tc={selected_tc_val}" in col]
                # Now find best among the filtered
                best_col = metric_BL[matching_cols].loc["Annualized Sharpe Ratio"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                # --- Update session state to reflect new parameters ---
                st.session_state["rolling_window_label"] = get_key_from_value(win_options,best_params["win"])
                st.session_state["target_vol_label"] = get_key_from_value(vol_options, best_params["tv"])
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["omega_value"] = best_params["omega"]   
            
        else:
            if st.button("üìà Max Sharpe", use_container_width=True,help="Finds the configuration that maximizes the annualized Sharpe ratio."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_win = st.session_state["rolling_window_label"]
                selected_vol = st.session_state["target_vol_label"]
                selected_tc_val = tc_options[selected_tc]
                selected_win_val = win_options[selected_win]
                selected_vol_val = vol_options[selected_vol]
                # Filter columns that contain value not changed
                matching_cols = [col for col in metric_BL.columns 
                                    if f'win={selected_win_val}'in col and 
                                    f'tc={selected_tc_val}_tv={selected_vol_val}' in col]
                best_col = metric_BL[matching_cols].loc["Annualized Sharpe Ratio"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["omega_value"] = best_params["omega"]
            
            
                
        st.markdown("</div>", unsafe_allow_html=True)

    with col2:
        st.markdown("<div style='padding-top: 28px;'>", unsafe_allow_html=True)
        if st.session_state["full_param_toggle"] == True:
            if st.button("üîâ Min Volatility", use_container_width=True, help="Finds the configuration with the lowest annualized volatility."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_tc_val = tc_options[selected_tc]
                # Filter columns that contain the correct tc
                matching_cols = [col for col in metric_BL.columns if f"tc={selected_tc_val}" in col]
                # Now find best among the filtered
                best_col = metric_BL[matching_cols].loc["Annualized Volatility"].idxmin()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                # --- Update session state to reflect new parameters ---
                st.session_state["rolling_window_label"] = get_key_from_value(win_options,best_params["win"])
                st.session_state["target_vol_label"] = get_key_from_value(vol_options, best_params["tv"])
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["omega_value"] = best_params["omega"] 
        else:
            if st.button("üîâ Min Volatility", use_container_width=True, help="Finds the configuration with the lowest annualized volatility."): 
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_win = st.session_state["rolling_window_label"]
                selected_vol = st.session_state["target_vol_label"]
                selected_tc_val = tc_options[selected_tc]
                selected_win_val = win_options[selected_win]
                selected_vol_val = vol_options[selected_vol]
                # Filter columns that contain value not changed
                matching_cols = [col for col in metric_BL.columns 
                                    if f'win={selected_win_val}'in col and 
                                    f'tc={selected_tc_val}_tv={selected_vol_val}' in col]
                best_col = metric_BL[matching_cols].loc["Annualized Volatility"].idxmin()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["omega_value"] = best_params["omega"]
                               
        st.markdown("</div>", unsafe_allow_html=True)

    with col3:
        st.markdown("<div style='padding-top: 28px;'>", unsafe_allow_html=True)
        if st.session_state["full_param_toggle"] == True:
            if st.button("üìâ Max Drawdown", use_container_width=True, help="Minimizes the maximum historical drawdown."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_tc_val = tc_options[selected_tc]
                # Filter columns that contain the correct tc
                matching_cols = [col for col in metric_BL.columns if f"tc={selected_tc_val}" in col]
                # Now find best among the filtered
                best_col = metric_BL[matching_cols].loc["Max Drawdown"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                # --- Update session state to reflect new parameters ---
                st.session_state["rolling_window_label"] = get_key_from_value(win_options,best_params["win"])
                st.session_state["target_vol_label"] = get_key_from_value(vol_options, best_params["tv"])
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["omega_value"] = best_params["omega"]     
                
        else:
            if st.button("üìâ Max Drawdown", use_container_width=True, help="Minimizes the maximum historical drawdown."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_win = st.session_state["rolling_window_label"]
                selected_vol = st.session_state["target_vol_label"]
                selected_tc_val = tc_options[selected_tc]
                selected_win_val = win_options[selected_win]
                selected_vol_val = vol_options[selected_vol]
                # Filter columns that contain value not changed
                matching_cols = [col for col in metric_BL.columns 
                                    if f'win={selected_win_val}'in col and 
                                    f'tc={selected_tc_val}_tv={selected_vol_val}' in col]
                best_col = metric_BL[matching_cols].loc["Max Drawdown"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["omega_value"] = best_params["omega"]
                       
        st.markdown("</div>", unsafe_allow_html=True)
    with col4:
        st.markdown("<div style='padding-top: 28px;'>", unsafe_allow_html=True)
        if st.session_state["full_param_toggle"] == True:
            if st.button("üöÄ Max Return", use_container_width=True, help="Finds the configuration with the highest total return."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_tc_val = tc_options[selected_tc]
                # Filter columns that contain the correct tc
                matching_cols = [col for col in metric_BL.columns if f"tc={selected_tc_val}" in col]
                # Now find best among the filtered
                best_col = metric_BL[matching_cols].loc["Annualized Return"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                # --- Update session state to reflect new parameters ---
                st.session_state["rolling_window_label"] = get_key_from_value(win_options,best_params["win"])
                st.session_state["target_vol_label"] = get_key_from_value(vol_options, best_params["tv"])
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["omega_value"] = best_params["omega"]  
                    
        else:
            if st.button("üöÄ Max Return", use_container_width=True, help="Finds the configuration with the highest total return."):
                # Get values that will not be changed
                selected_tc = st.session_state["trans_cost_label"]
                selected_win = st.session_state["rolling_window_label"]
                selected_vol = st.session_state["target_vol_label"]
                selected_tc_val = tc_options[selected_tc]
                selected_win_val = win_options[selected_win]
                selected_vol_val = vol_options[selected_vol]
                # Filter columns that contain value not changed
                matching_cols = [col for col in metric_BL.columns 
                                    if f'win={selected_win_val}'in col and 
                                    f'tc={selected_tc_val}_tv={selected_vol_val}' in col]
                best_col = metric_BL[matching_cols].loc["Annualized Return"].idxmax()
                # 3. Parse the column name to extract parameters
                best_params = params_BL[params_BL['col_name'] == best_col].iloc[0]
                st.session_state["risk_aversion_value"] = best_params["risk"]
                st.session_state["omega_value"] = best_params["omega"]
                    
        st.markdown("</div>", unsafe_allow_html=True)
            

    with col5: 
        win_label_select = st.selectbox(
            "Rolling window", options=list(win_options.keys()),
            key="rolling_window_label",help="Sets the lookback period for signal calculation.")
        window = win_options[st.session_state["rolling_window_label"]]
        
        
    with col6:  
        vt_label_select = st.selectbox(
            "Target volatility", options=list(vol_options.keys()),
            key="target_vol_label",
            help="Adjusts portfolio weights to maintain a target annualized volatility level.")
        target_vol = vol_options[st.session_state["target_vol_label"]]

    
    with col7:
        tc_label_select = st.selectbox(
            "Transaction costs", options=list(tc_options.keys()),
            key="trans_cost_label",
            help="Specifies the transaction cost applied at each rebalancing step.")
        trans_cost = tc_options[st.session_state["trans_cost_label"]]
            

    with col8:
        risk_aversion = st.select_slider("Risk aversion",options=[0.1,0.3,0.5,0.7,0.9,1],key="risk_aversion_value",
                                         help="Controls how conservative the optimizer is. Higher values mean lower risk-taking.(Not in this strategy, need further diagnosys)")
        
        
    with col9:
        omega = st.select_slider("Omega",options=[0.006,0.008,0.010,0.012,0.014,0.016,0.018,
                                                    0.020,0.022,0.024,0.026,0.028,0.030,0.032,
                                                    0.034,0.036,0.038,0.040,0.045,0.05,0.06,
                                                    0.08,0.1],key="omega_value",
                                                    help="Scales the uncertainty in the views. Higher omega means weaker confidence.")
                     

        
    st.markdown("#### üìà Portfolios Performance")
    col1,col2 = st.columns([1,3])
    with col1:
        
            # --- Select the correct column based on slider inputs ---
        selected_col_BL = params_BL[
            (params_BL['win'] == window) &
            (params_BL['risk'] == risk_aversion) &
            (params_BL['omega'] == omega) &
            (params_BL['tc'] == trans_cost) &
            (params_BL['tv'] == target_vol) 
        ]['col_name'].values

        selected_col_NV = params_NV[
            (params_NV['win'] == window) &
            (params_NV['risk'] == risk_aversion) &
            (params_NV['tc'] == trans_cost) &
            (params_NV['tv'] == target_vol) 
        ]['col_name'].values

        selected_col_VW = params_VW[
            (params_VW['tc'] == trans_cost) &
            (params_VW['tv'] == target_vol) 
        ]['col_name'].values



        data = {
            "Metric": metric_BL.index,
            "Portfolio with Views": format_metric(metric_BL.index, metric_BL[selected_col_BL]),
            "Portfolio without Views": format_metric(metric_NV.index, metric_NV[selected_col_NV]),
            "Market Portfolio": format_metric(metric_VW.index, metric_VW[selected_col_VW]),
        }

        df = pd.DataFrame(data)




        def render_metric_table(df):
            header = "".join([f"<th>{col}</th>" for col in df.columns])
            rows = ""
            for _, row in df.iterrows():
                cells = "".join([f"<td>{val}</td>" for val in row])
                rows += f"<tr>{cells}</tr>"

            html = f"""
            <style>
            .metric-table {{
                font-size: 13px;
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
                font-family: 'Segoe UI', sans-serif;
            }}
            .metric-table th {{
                background-color: #f0f0f0;
                color: #333;
                padding: 6px 10px;
                text-align: center;
                border-bottom: 1px solid #ccc;
            }}
            .metric-table td {{
                padding: 6px 10px;
                text-align: center;
                border-bottom: 1px solid #eee;
            }}
            .metric-table tr:hover {{
                background-color: #f9f9f9;
            }}
            </style>

            <table class="metric-table">
                <thead><tr>{header}</tr></thead>
                <tbody>{rows}</tbody>
            </table>
            """

            st.markdown(html, unsafe_allow_html=True)



        render_metric_table(df)
        
        
        
    with col2:
                    
        # --- Prepare data for ploting ---
        # BL
        plot_cr_BL = cum_ret_BL[selected_col_BL].reset_index()
        plot_cr_BL.columns = ['Date', 'Cumulative Return'] 
        plot_cr_BL['Cumulative Return'] = plot_cr_BL['Cumulative Return'].astype(float)
        
        plot_dd_BL = dd_BL[selected_col_BL].reset_index()
        plot_dd_BL.columns = ['Date', 'Drawdown'] 
        plot_dd_BL['Drawdown'] = plot_dd_BL['Drawdown'].astype(float)
        
        # NV
        plot_cr_NV = cum_ret_NV[selected_col_NV].reset_index()
        plot_cr_NV.columns = ['Date', 'Cumulative Return'] 
        plot_cr_NV['Cumulative Return'] = plot_cr_NV['Cumulative Return'].astype(float)
        
        plot_dd_NV = dd_NV[selected_col_NV].reset_index()
        plot_dd_NV.columns = ['Date', 'Drawdown'] 
        plot_dd_NV['Drawdown'] = plot_dd_NV['Drawdown'].astype(float)
        # VW
        plot_cr_VW = cum_ret_VW[selected_col_VW].reset_index()
        plot_cr_VW.columns = ['Date', 'Cumulative Return'] 
        plot_cr_VW['Cumulative Return'] = plot_cr_VW['Cumulative Return'].astype(float)
        
        plot_dd_VW = dd_VW[selected_col_VW].reset_index()
        plot_dd_VW.columns = ['Date', 'Drawdown'] 
        plot_dd_VW['Drawdown'] = plot_dd_VW['Drawdown'].astype(float)
        
        latest_BL = plot_cr_BL.sort_values("Date").iloc[-1] 
        latest_NV = plot_cr_NV.sort_values("Date").iloc[-1] 
        latest_VW = plot_cr_VW.sort_values("Date").iloc[-1]
        
        latest_returns = pd.DataFrame({
        "Date": [latest_BL["Date"], latest_NV["Date"], latest_VW["Date"]],
        "Total Return": [latest_BL["Cumulative Return"] -1 , latest_NV["Cumulative Return"] -1, latest_VW["Cumulative Return"]-1],
        "Portfolio": ["Portfolio with Views", "Portfolio without Views", "Market Portfolio"]
        })
        
    
        # --- Name portfolios ---
        plot_cr_BL['Strategy'] = 'Portfolio with Views'
        plot_cr_NV['Strategy'] = 'Portfolio without Views'
        plot_cr_VW['Strategy'] = 'Market Portfolio'
        
        plot_dd_BL['Strategy'] = 'Portfolio with Views'
        plot_dd_NV['Strategy'] = 'Portfolio without Views'
        plot_dd_VW['Strategy'] = 'Market Portfolio'
    
        # Combine into one long-format DataFrame
        combined_data_cr = pd.concat([plot_cr_BL, plot_cr_NV,plot_cr_VW], ignore_index=True)
        combined_data_cr["Cumulative Return"] = combined_data_cr["Cumulative Return"] - 1
        combined_data_dd = pd.concat([plot_dd_BL, plot_dd_NV,plot_dd_VW], ignore_index=True)
        
        combined_data = pd.merge(
        combined_data_cr,
        combined_data_dd,
        on=["Date", "Strategy"],
        how="inner"
        )
    
            # Pivot data to wide format
        pivoted = combined_data.pivot(index="Date", columns="Strategy", values=["Cumulative Return", "Drawdown"]).reset_index()
        # Flatten MultiIndex columns
        pivoted.columns = ['Date'] + [f"{metric} {strategy}" for metric, strategy in pivoted.columns[1:]]
        pivoted["Tooltip VW"] = pivoted.apply(
            lambda row: f"Views \u2003\u2009\u2009\u2009\u200A\u200A\u200A| R: {row['Cumulative Return Portfolio with Views']:.1%} | DD: {row['Drawdown Portfolio with Views']:.1%}",
            axis=1
        )
        pivoted["Tooltip NV"] = pivoted.apply(
            lambda row: f"No Views | R: {row['Cumulative Return Portfolio without Views']:.1%} | DD: {row['Drawdown Portfolio without Views']:.1%}",
            axis=1
        )
        pivoted["Tooltip MP"] = pivoted.apply(
            lambda row: f"Market \u00A0\u00A0\u00A0\u2009 | R: {row['Cumulative Return Market Portfolio']:.1%} | DD: {row['Drawdown Market Portfolio']:.1%}",
            axis=1
        )
    
        # --- Create the nearest-point selection ---
        nearest = alt.selection_point(
            nearest=True,
            on="pointerover",
            fields=["Date"],
            empty=False
        )
    
        # --- Line chart for Cumulative Return ---
        line_cr = alt.Chart(combined_data).mark_line(strokeWidth=1.5).encode(
            x=alt.X("Date:T", axis=None),
            y=alt.Y("Cumulative Return:Q", title="Total Return", axis=alt.Axis(format=".0%")),
            color=alt.Color(
                "Strategy:N",
                title="",
                scale=alt.Scale(
                    domain=["Portfolio with Views", "Portfolio without Views", "Market Portfolio"],
                    range=['#2ca02c', '#d62728', '#1f77b4']
                )
            )
        )
        min_dd = combined_data_dd["Drawdown"].min()
    
        # --- Line chart for Drawdown ---
        line_dd = alt.Chart(combined_data).mark_line(strokeWidth=1.5).encode(
            x=alt.X("Date:T", title="Date"),
            y=alt.Y("Drawdown:Q", title="Drawdown", axis=alt.Axis(format=".0%"),
                    scale=alt.Scale(domain=[min_dd, 0.01],nice=False)),
            color=alt.Color(
                "Strategy:N", legend=alt.Legend(orient='top-left'),
                title="",
                scale=alt.Scale(
                    domain=["Portfolio with Views", "Portfolio without Views", "Market Portfolio"],
                    range=['#2ca02c', '#d62728', '#1f77b4']
                )
            )
        )
    
        # --- Points for Return chart ---
        points_cr = alt.Chart(combined_data).mark_point().encode(
            x="Date:T",
            y="Cumulative Return:Q",
            color=alt.Color("Strategy:N", scale=alt.Scale(
                domain=["Portfolio with Views", "Portfolio without Views", "Market Portfolio"],
                range=["#2ca02c", "#d62728", "#1f77b4"]
            )),
            opacity=alt.condition(nearest, alt.value(1), alt.value(0))
        )
    
        # --- Points for Drawdown chart ---
        points_dd = alt.Chart(combined_data).mark_point().encode(
            x="Date:T",
            y="Drawdown:Q",
            color=alt.Color("Strategy:N", scale=alt.Scale(
                domain=["Portfolio with Views", "Portfolio without Views", "Market Portfolio"],
                range=["#2ca02c", "#d62728", "#1f77b4"]
            )),
            opacity=alt.condition(nearest, alt.value(1), alt.value(0))
        )
    
        
        tooltip=[
            alt.Tooltip("Date:T", title="    "),
            alt.Tooltip("Tooltip VW:N", title=" "),
            alt.Tooltip("Tooltip NV:N", title="  "),
            alt.Tooltip("Tooltip MP:N", title="   "),
        ]
        
        zero_line = alt.Chart(pivoted).mark_rule(color='black', strokeWidth=1).encode(
            y=alt.datum(0))
        text_labels = alt.Chart(latest_returns).mark_text(
            align='left',
            dx=5,
            dy=0,
            fontSize=12,
            fontWeight='bold'
        ).encode(
            x="Date:T",
            y=alt.Y("Total Return:Q"),
            text=alt.Text("Total Return:Q", format=".1%"),
            color="Portfolio:N"
        )
    
    
        rules = alt.Chart(pivoted).mark_rule(color="gray").encode(
            x="Date:T",
            opacity=alt.condition(nearest, alt.value(0.3), alt.value(0)),
            tooltip=tooltip
        ).add_params(nearest)
    
    
    
    
    
        chart_cr = alt.layer(line_cr, points_cr, rules,text_labels).properties(
            width=800,
            height=250,
        )
    
        chart_dd = alt.layer(line_dd, points_dd, rules,zero_line).properties(
            width=800,
            height=180,
        )
    
        # --- Final synchronized display ---
        full_chart = alt.vconcat(chart_cr, chart_dd,spacing=0).resolve_scale(x='shared').configure_title(
        anchor='middle'  # Use 'start', 'middle', or 'end'
        )
    
        st.write(f"Selected Omega: {omega}")
        with st.container():
            st.altair_chart(full_chart, use_container_width=True)




